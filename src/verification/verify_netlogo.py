"""
NetLogo Code Verifier Module

This module provides functionality to validate and verify NetLogo code generated by LLMs.
It ensures the code is syntactically correct, safe to execute, and follows best practices
for movement rules that agents use to explore the environment.

Dependencies:
- Python 3.8+
- Standard library modules: re, typing
"""

import re
from typing import List, Tuple, Set, Dict, Optional, Union, Pattern
from dataclasses import dataclass
from enum import Enum
import logging

logger = logging.getLogger(__name__)

class ErrorSeverity(Enum):
    """Severity levels for validation errors."""
    WARNING = "warning"
    ERROR = "error"

@dataclass
class ValidationError:
    """Class to represent validation errors with context."""
    message: str
    line_number: Optional[int] = None
    code_snippet: Optional[str] = None
    severity: ErrorSeverity = ErrorSeverity.ERROR

    def __str__(self) -> str:
        """String representation of the validation error."""
        location = f" at line {self.line_number}" if self.line_number is not None else ""
        snippet = f"\n  Code: '{self.code_snippet}'" if self.code_snippet else ""
        return f"{self.severity.value.upper()}{location}: {self.message}{snippet}"

@dataclass
class ValidationResult:
    """Result of a validation check."""
    is_valid: bool
    errors: List[ValidationError] = None

    def __init__(self, is_valid: bool, errors: Optional[List[ValidationError]] = None):
        self.is_valid = is_valid
        self.errors = errors or []

    def add_error(self, error: ValidationError) -> None:
        """Add an error to the result."""
        self.errors.append(error)
        self.is_valid = False

    def merge(self, other: 'ValidationResult') -> None:
        """Merge another validation result into this one."""
        self.is_valid = self.is_valid and other.is_valid
        self.errors.extend(other.errors)

class CodeComplexity(Enum):
    """Complexity levels for NetLogo code."""
    SIMPLE = 1      # Basic movement without conditions
    BASIC = 2       # Simple conditionals
    MODERATE = 3    # Multiple conditions, basic sensing
    ADVANCED = 4    # Complex conditions, environment awareness
    COMPLEX = 5     # Advanced sensing, memory usage
    SOPHISTICATED = 6  # Multiple strategies, adaptation
    EXPERT = 7      # Optimal pathfinding, complex decision making

class NetLogoVerifier:
    """
    NetLogo Code Verification and Validation Class
    
    This class provides comprehensive validation for NetLogo code generated by LLMs,
    focusing on verifying movement rules that agents use to explore environments.
    
    Public Methods:
    - is_safe(code: str) -> Tuple[bool, str]: Main validation method
    - validate(code: str) -> ValidationResult: Detailed validation with multiple errors
    - measure_complexity(code: str) -> CodeComplexity: Measures code complexity
    """
    def __init__(self, config: Optional[Dict] = None):
        """
        Initialize verifier with optional configuration.
        
        Args:
            config: Optional dictionary with configuration parameters
        """
        self.config = config or {}
        
        # Configure limits
        self.max_code_length = self.config.get("max_code_length", 10000)
        self.max_value = self.config.get("max_value", 1000)
        self.min_value = self.config.get("min_value", -1000)
        
        # Allowed NetLogo primitives
        self.allowed_commands = {
            # Movement commands
            'fd', 'forward',
            'rt', 'right',
            'lt', 'left',
            'bk', 'back',
            # Control structures
            'if', 'ifelse', 'ifelse-value',
            # Variable operations
            'set', 'let'
        }
        
        self.allowed_reporters = {
            # Random generators
            'random', 'random-float',
            # Math functions
            'sin', 'cos', 'tan',
            # List operations
            'item', 'count', 'length', 'position',
            # Agent properties
            'xcor', 'ycor', 'heading',
            # Agent sensing
            'any?', 'in-radius', 'distance', 'towards',
            # Logic
            'and', 'or', 'not'
        }
        
        self.dangerous_primitives = {
            # Agent lifecycle
            'die', 'kill', 'create', 'hatch', 'sprout',
            # Agent control
            'ask', 'of', 'with',
            # Code execution
            'run', 'runresult',
            # File operations
            'file', 'import', 'export',
            # External code
            'python', 'js',
            # Simulation control
            'clear', 'reset', 'setup', 'go',
            # Loops
            'while', 'loop', 'repeat', 'forever',
            # Breeds
            'breed', 'create-ordered',
            # Network/extension operations
            'hubnet', 'gis', 'sql',
            # System operations
            'wait', 'beep', 'system',
            # Global state
            'clear-all', 'reset-ticks'
        }
        
        self.arithmetic_operators = {'+', '-', '*', '/', '^'}
        self.comparison_operators = {'=', '!=', '>', '<', '>=', '<='}
        self.allowed_variables = {
            'input', 'energy', 'lifetime', 'food-collected', 
            'xcor', 'ycor', 'heading', 'who', 'input-resource-distances', 'input-resource-types',
            'food-observations', 'poison-observations', '"silver"', '"gold"', '"crystal"'
        }
        
        # Precompile regex patterns for performance
        self._compile_regex_patterns()

    def _compile_regex_patterns(self) -> None:
        """Precompile regex patterns for better performance."""
        self.number_pattern = re.compile(r'[+-]?\d+(\.\d+)?([eE][+-]?\d+)?')
        self.reporter_pattern = re.compile(
            r'^(random(-float)?|sin|cos|tan)\s+([a-zA-Z\-]+|\d+(\.\d+)?([eE][+-]?\d+)?)$'
        )
        self.variable_pattern = re.compile(r'^[a-zA-Z][\w\-]*$')
        self.comment_pattern = re.compile(r';.*$', re.MULTILINE)

    def is_safe(self, code: str) -> Tuple[bool, str]:
        """
        Simplified interface to validate NetLogo code for safety and correctness.
        
        Args:
            code: The NetLogo code to validate
            
        Returns:
            Tuple containing:
                - bool: True if code is safe, False otherwise
                - str: Error message if code is unsafe, empty string if safe
        """
        result = self.validate(code)
        if not result.is_valid:
            return False, "\n".join(str(error) for error in result.errors)
        return True, "Code appears safe"

    def validate(self, code: str) -> ValidationResult:
        """
        Comprehensive validation of NetLogo code with detailed error reporting.
        
        Args:
            code: The NetLogo code to validate
            
        Returns:
            ValidationResult: Contains validation status and list of errors
        """
        result = ValidationResult(True)
        
        # Track line numbers for better error reporting
        lines = code.split('\n')
        cleaned_lines = []
        
        # Clean each line individually and track line numbers
        for i, line in enumerate(lines):
            cleaned = self._clean_code(line)
            if cleaned:  # Only keep non-empty lines
                cleaned_lines.append((i + 1, cleaned))
        
        # Early validation for empty code
        if not cleaned_lines:
            result.add_error(ValidationError("Empty code or only comments"))
            return result
        
        # Create a complete cleaned version for tokenization
        cleaned_code = "\n".join(line for _, line in cleaned_lines)
        
        # Code length check
        if len(cleaned_code) > self.max_code_length:
            result.add_error(ValidationError(
                f"Code exceeds maximum length of {self.max_code_length} characters"
            ))
            return result
        
        # Basic structural validation - these are fast and can exit early
        validations = [
            self._check_dangerous_primitives,
            self._check_brackets_balance,
        ]
        
        for validation in validations:
            validation_result = validation(cleaned_code, cleaned_lines)
            if not validation_result.is_valid:
                result.merge(validation_result)
                return result  # Exit early on critical failures
        
        # More detailed validations - collect all errors
        detailed_validations = [
            self._check_movement_commands,
            self._check_command_syntax,
            self._check_value_ranges,
        ]
        
        for validation in detailed_validations:
            validation_result = validation(cleaned_code, cleaned_lines)
            result.merge(validation_result)
            
        return result

    def _clean_code(self, code: str) -> str:
        """
        Preprocess NetLogo code for validation.
        
        Args:
            code: Raw NetLogo code to clean
            
        Returns:
            Cleaned code ready for validation
        """
        # Remove any comments (;; or ;)
        code = self.comment_pattern.sub('', code)
        # Normalize whitespace but preserve brackets
        code = re.sub(r'\s+', ' ', code)
        # Add space around brackets for tokenization
        code = re.sub(r'\[', ' [ ', code)
        code = re.sub(r'\]', ' ] ', code)
        code = re.sub(r'\(', ' ( ', code)
        code = re.sub(r'\)', ' ) ', code)
        return code.strip()

    def _find_line_for_position(self, code_lines: List[Tuple[int, str]], 
                               token: str, start_pos: int = 0) -> Optional[int]:
        """
        Find the line number where a token appears.
        
        Args:
            code_lines: List of tuples (line_number, code)
            token: Token to find
            start_pos: Position to start searching from
            
        Returns:
            Line number where token was found, or None if not found
        """
        cumulative_length = 0
        for line_num, line in code_lines:
            line_length = len(line) + 1  # +1 for newline
            if start_pos <= cumulative_length <= start_pos + len(token):
                return line_num
            cumulative_length += line_length
        return None

    def _check_dangerous_primitives(self, code: str, 
                                   code_lines: List[Tuple[int, str]]) -> ValidationResult:
        """
        Validate code against known dangerous NetLogo primitives.
        
        Args:
            code: The code to validate
            code_lines: List of tuples (line_number, code)
            
        Returns:
            ValidationResult with any dangerous primitives found
        """
        result = ValidationResult(True)
        words = set(re.findall(r'\b\w+\b', code.lower()))
        dangerous_found = words.intersection(self.dangerous_primitives)
        
        if dangerous_found:
            for primitive in dangerous_found:
                # Find line where primitive occurs
                match = re.search(r'\b' + primitive + r'\b', code.lower())
                if match:
                    line_num = self._find_line_for_position(code_lines, primitive, match.start())
                    context = code[max(0, match.start()-10):match.start()+len(primitive)+10]
                    result.add_error(ValidationError(
                        f"Dangerous primitive found: {primitive}",
                        line_number=line_num,
                        code_snippet=context
                    ))
        
        return result

    def _check_brackets_balance(self, code: str, 
                               code_lines: List[Tuple[int, str]]) -> ValidationResult:
        """
        Validate proper nesting and balance of brackets in NetLogo code.
        
        Args:
            code: The code to validate
            code_lines: List of tuples (line_number, code)
            
        Returns:
            ValidationResult with any bracket issues
        """
        result = ValidationResult(True)
        stack = []
        brackets = {'(': ')', '[': ']', '{': '}'}
        
        for i, char in enumerate(code):
            if char in brackets.keys():
                stack.append((char, i))
            elif char in brackets.values():
                if not stack:
                    line_num = self._find_line_for_position(code_lines, char, i)
                    context = code[max(0, i-10):i+10]
                    result.add_error(ValidationError(
                        "Unmatched closing bracket",
                        line_number=line_num,
                        code_snippet=context
                    ))
                    return result
                
                opening_bracket, pos = stack.pop()
                if char != brackets[opening_bracket]:
                    line_num = self._find_line_for_position(code_lines, char, i)
                    context = code[max(0, i-10):i+10]
                    result.add_error(ValidationError(
                        f"Mismatched brackets: {opening_bracket} and {char}",
                        line_number=line_num,
                        code_snippet=context
                    ))
                    return result
        
        if stack:
            # Report unclosed brackets
            for opening_bracket, pos in stack:
                line_num = self._find_line_for_position(code_lines, opening_bracket, pos)
                context = code[max(0, pos-10):pos+10]
                result.add_error(ValidationError(
                    f"Unclosed bracket: {opening_bracket}",
                    line_number=line_num,
                    code_snippet=context
                ))
        
        return result

    def _check_movement_commands(self, code: str, 
                                code_lines: List[Tuple[int, str]]) -> ValidationResult:
        """
        Verify that the code contains at least one movement command.
        
        Args:
            code: The code to validate
            code_lines: List of tuples (line_number, code)
            
        Returns:
            ValidationResult with error if no movement commands found
        """
        result = ValidationResult(True)
        
        # Check if this is an ifelse-value expression, which is allowed to not have movement commands
        # as it returns a value rather than executing commands
        if "ifelse-value" in code.lower():
            return result
        
        # Code should contain at least one movement command
        movement_commands = {'fd', 'forward', 'rt', 'right', 'lt', 'left', 'bk', 'back'}
        words = set(re.findall(r'\b\w+\b', code.lower()))
        movement_found = words.intersection(movement_commands)
        
        if not movement_found:
            result.add_error(ValidationError(
                "No movement commands found. Code must include at least one movement command: fd, rt, lt, or bk",
                severity=ErrorSeverity.ERROR
            ))
        
        return result

    def _check_command_syntax(self, code: str, 
                             code_lines: List[Tuple[int, str]]) -> ValidationResult:
        """
        Validate syntax of NetLogo commands and control structures.
        
        Args:
            code: The code to validate
            code_lines: List of tuples (line_number, code)
            
        Returns:
            ValidationResult with any syntax errors
        """
        result = ValidationResult(True)
        
        # Tokenize the code
        tokens = []
        for line_num, line in code_lines:
            line_tokens = line.split()
            tokens.extend([(token, line_num) for token in line_tokens])
        
        i = 0
        while i < len(tokens):
            token, line_num = tokens[i]
            token_lower = token.lower()
            
            # Handle if/ifelse statements
            if token_lower in {'if', 'ifelse', 'ifelse-value'}:
                if_result, new_i = self._validate_if_statement(tokens, i)
                if not if_result.is_valid:
                    result.merge(if_result)
                i = new_i
                continue
            
            # Handle regular commands
            if token_lower in self.allowed_commands:
                command_result, new_i = self._validate_command(tokens, i)
                if not command_result.is_valid:
                    result.merge(command_result)
                i = new_i
                continue
            
            # Skip tokens we don't specifically need to validate
            i += 1
        
        return result

    def _validate_if_statement(self, tokens: List[Tuple[str, int]], 
                              start_idx: int) -> Tuple[ValidationResult, int]:
        """
        Validate an if, ifelse, or ifelse-value statement. Supports both simple and 
        multi-conditional formats.
        
        Args:
            tokens: List of tokens with line numbers
            start_idx: Starting index of the if statement
            
        Returns:
            Tuple containing:
                - ValidationResult with any errors
                - New index position after the if statement
        """
        result = ValidationResult(True)
        i = start_idx
        statement_type, line_num = tokens[i]
        statement_type = statement_type.lower()
        
        # Check if this is a parenthesized multi-conditional format
        is_multi_conditional = False
        
        # Check if the statement is inside parentheses
        if i > 0 and tokens[i-1][0] == '(':
            is_multi_conditional = True
        elif i + 1 < len(tokens) and tokens[i+1][0] == '(':
            is_multi_conditional = True
            i += 1  # Skip the opening parenthesis
        
        # If it's a multi-conditional ifelse/ifelse-value, use the specialized handler
        if is_multi_conditional and statement_type in {'ifelse', 'ifelse-value'}:
            return self._validate_multi_conditional(tokens, i, statement_type)
        
        # Move past the statement token for standard if/ifelse
        i += 1
        
        # Check if we have enough tokens for a condition
        if i >= len(tokens):
            result.add_error(ValidationError(
                f"Incomplete {statement_type} statement - missing condition",
                line_number=line_num
            ))
            return result, i
        
        # Find the condition end (the opening bracket of the true branch)
        condition_end = i
        while condition_end < len(tokens) and tokens[condition_end][0] != '[':
            condition_end += 1
        
        if condition_end >= len(tokens):
            result.add_error(ValidationError(
                f"Incomplete {statement_type} statement - missing opening bracket",
                line_number=line_num
            ))
            return result, i
        
        # Validate the condition
        condition_tokens = tokens[i:condition_end]
        condition_result = self._validate_condition(condition_tokens)
        if not condition_result.is_valid:
            result.merge(condition_result)
        
        # Move past the condition
        i = condition_end + 1  # Skip the opening bracket
        
        # Find matching closing bracket for true branch
        bracket_count = 1
        true_branch_start = i
        while i < len(tokens) and bracket_count > 0:
            if tokens[i][0] == '[':
                bracket_count += 1
            elif tokens[i][0] == ']':
                bracket_count -= 1
            i += 1
        
        if bracket_count > 0:
            result.add_error(ValidationError(
                f"Unclosed bracket in {statement_type} true branch",
                line_number=tokens[true_branch_start-1][1]
            ))
            return result, i
        
        true_branch_end = i - 1  # Last token of true branch
        
        # Validate the true branch
        true_branch_result = self._validate_branch_contents(
            tokens[true_branch_start:true_branch_end]
        )
        if not true_branch_result.is_valid:
            result.merge(true_branch_result)
        
        # For ifelse and ifelse-value, we need to check the false branch
        if statement_type in {'ifelse', 'ifelse-value'}:
            # Check that we have an opening bracket for false branch
            if i >= len(tokens) or tokens[i][0] != '[':
                result.add_error(ValidationError(
                    f"Missing false branch for {statement_type}",
                    line_number=tokens[true_branch_end][1]
                ))
                return result, i
            
            i += 1  # Skip the opening bracket
            
            # Find matching closing bracket for false branch
            bracket_count = 1
            false_branch_start = i
            while i < len(tokens) and bracket_count > 0:
                if tokens[i][0] == '[':
                    bracket_count += 1
                elif tokens[i][0] == ']':
                    bracket_count -= 1
                i += 1
            
            if bracket_count > 0:
                result.add_error(ValidationError(
                    f"Unclosed bracket in {statement_type} false branch",
                    line_number=tokens[false_branch_start-1][1]
                ))
                return result, i
            
            false_branch_end = i - 1  # Last token of false branch
            
            # Validate the false branch
            false_branch_result = self._validate_branch_contents(
                tokens[false_branch_start:false_branch_end]
            )
            if not false_branch_result.is_valid:
                result.merge(false_branch_result)
        
        return result, i

    def _validate_multi_conditional(self, tokens: List[Tuple[str, int]],
                                   start_idx: int, 
                                   statement_type: str) -> Tuple[ValidationResult, int]:
        """
        Validate a multi-conditional ifelse or ifelse-value statement in the format:
        (ifelse boolean1 [ commands1 ] boolean2 [ commands2 ] ... [ elsecommands ])
        (ifelse-value boolean1 [ reporter1 ] boolean2 [ reporter2 ] ... [ elsereporter ])
        
        Args:
            tokens: List of tokens with line numbers
            start_idx: Starting index of the statement
            statement_type: Either 'ifelse' or 'ifelse-value'
            
        Returns:
            Tuple containing:
                - ValidationResult with any errors
                - New index position after the statement
        """
        result = ValidationResult(True)
        i = start_idx
        line_num = tokens[i][1]
        
        # Skip past the statement type token
        i += 1
        
        # Track whether we found the final else branch
        found_final_else = False
        
        # Process condition-branch pairs until we find the final else branch
        while i < len(tokens):
            # If we encounter a closing parenthesis, we're done
            if tokens[i][0] == ')':
                i += 1
                break
                
            # If we find an opening bracket without a condition first,
            # this is the final else branch
            if tokens[i][0] == '[':
                # Validate final else branch
                bracket_count = 1
                else_branch_start = i + 1
                i += 1  # Skip the opening bracket
                
                while i < len(tokens) and bracket_count > 0:
                    if tokens[i][0] == '[':
                        bracket_count += 1
                    elif tokens[i][0] == ']':
                        bracket_count -= 1
                    i += 1
                
                if bracket_count > 0:
                    result.add_error(ValidationError(
                        f"Unclosed bracket in {statement_type} else branch",
                        line_number=tokens[else_branch_start-1][1]
                    ))
                    return result, i
                
                else_branch_end = i - 1
                
                # Validate the else branch
                else_branch_result = self._validate_branch_contents(
                    tokens[else_branch_start:else_branch_end]
                )
                if not else_branch_result.is_valid:
                    result.merge(else_branch_result)
                
                found_final_else = True
                
                # Look for a closing parenthesis
                if i < len(tokens) and tokens[i][0] == ')':
                    i += 1
                    
                break
            
            # Validate a condition
            condition_end = i
            while condition_end < len(tokens) and tokens[condition_end][0] != '[':
                condition_end += 1
            
            if condition_end >= len(tokens):
                result.add_error(ValidationError(
                    f"Incomplete {statement_type} statement - missing opening bracket",
                    line_number=tokens[i][1]
                ))
                return result, i
            
            # Validate the condition
            condition_tokens = tokens[i:condition_end]
            condition_result = self._validate_condition(condition_tokens)
            if not condition_result.is_valid:
                result.merge(condition_result)
            
            # Move past the condition to the opening bracket
            i = condition_end + 1  # Skip the opening bracket
            
            # Find matching closing bracket for this branch
            bracket_count = 1
            branch_start = i
            while i < len(tokens) and bracket_count > 0:
                if tokens[i][0] == '[':
                    bracket_count += 1
                elif tokens[i][0] == ']':
                    bracket_count -= 1
                i += 1
            
            if bracket_count > 0:
                result.add_error(ValidationError(
                    f"Unclosed bracket in {statement_type} branch",
                    line_number=tokens[branch_start-1][1]
                ))
                return result, i
            
            branch_end = i - 1
            
            # Validate the branch
            branch_result = self._validate_branch_contents(
                tokens[branch_start:branch_end]
            )
            if not branch_result.is_valid:
                result.merge(branch_result)
        
        # Verify that we found a final else branch
        if not found_final_else:
            result.add_error(ValidationError(
                f"Missing final else branch in {statement_type} statement",
                line_number=line_num,
                severity=ErrorSeverity.ERROR
            ))
        
        return result, i

    def _validate_condition(self, tokens: List[Tuple[str, int]]) -> ValidationResult:
        """
        Validate a condition expression.
        
        Args:
            tokens: List of tokens with line numbers for the condition
            
        Returns:
            ValidationResult with any errors in the condition
        """
        result = ValidationResult(True)
        
        if not tokens:
            result.add_error(ValidationError("Empty condition"))
            return result
        
        # Join tokens to analyze the condition as a whole
        condition_str = " ".join(token for token, _ in tokens)
        line_num = tokens[0][1]  # Use line number of first token for errors
        
        # Check for logical operators (and/or)
        if " and " in condition_str:
            parts = condition_str.split(" and ")
            for part in parts:
                part_result = self._validate_simple_condition(part.strip(), line_num)
                if not part_result.is_valid:
                    result.merge(part_result)
            return result
        
        if " or " in condition_str:
            parts = condition_str.split(" or ")
            for part in parts:
                part_result = self._validate_simple_condition(part.strip(), line_num)
                if not part_result.is_valid:
                    result.merge(part_result)
            return result
        
        # If no logical operators, validate as a simple condition
        return self._validate_simple_condition(condition_str, line_num)
    
    def _validate_simple_condition(self, condition_str: str, line_num: int) -> ValidationResult:
        """
        Validate a simple condition without logical operators.
        
        Args:
            condition_str: The condition string to validate
            line_num: Line number for error reporting
            
        Returns:
            ValidationResult with any errors in the condition
        """
        result = ValidationResult(True)
        
        # Check for common condition patterns
        # 1. Simple comparisons: <value> <operator> <value>
        pattern = r'^(.+?)\s*(=|!=|>|<|>=|<=)\s*(.+)$'
        match = re.match(pattern, condition_str)
        #return result ## DEBUGGINGNJGNGG
        if match:
            return result # DEBUGGINGGGGGG
            left, op, right = match.groups()
            
            # Check left side
            left_valid = (self._is_valid_numeric_expression(left) or 
                          left.lower() in self.allowed_variables or
                          self._is_valid_reporter_expression(left))
            
            # Check right side
            right_valid = (self._is_valid_numeric_expression(right) or 
                           right.lower() in self.allowed_variables or
                           self._is_valid_reporter_expression(right))
            
            if not left_valid:
                result.add_error(ValidationError(
                    f"Invalid left side of condition: {left}",
                    line_number=line_num,
                    code_snippet=condition_str
                ))
            
            if not right_valid:
                result.add_error(ValidationError(
                    f"Invalid right side of condition: {right}",
                    line_number=line_num,
                    code_snippet=condition_str
                ))
            
            return result
        
        # 2. Check for reporter expressions
        if self._is_valid_reporter_expression(condition_str):
            return result
        
        # 3. Check for negation ('not' operator)
        if condition_str.lower().startswith("not "):
            inner_condition = condition_str[4:].strip()
            return self._validate_simple_condition(inner_condition, line_num)
        
        # If we get here, the condition doesn't match known patterns
        result.add_error(ValidationError(
            f"Invalid or unsupported condition: {condition_str}",
            line_number=line_num,
            code_snippet=condition_str
        ))
        
        return result

    def _validate_branch_contents(self, tokens: List[Tuple[str, int]]) -> ValidationResult:
        """
        Validate the contents of an if/ifelse branch.
        
        Args:
            tokens: List of tokens with line numbers for the branch
            
        Returns:
            ValidationResult with any errors in the branch
        """
        result = ValidationResult(True)
        
        if not tokens:
            # Empty branches are technically valid but suspicious
            result.add_error(ValidationError(
                "Empty branch in conditional statement",
                line_number=tokens[0][1] if tokens else None,
                severity=ErrorSeverity.WARNING
            ))
            return result
        
        # Process tokens sequentially looking for valid commands
        i = 0
        while i < len(tokens):
            token, line_num = tokens[i]
            token_lower = token.lower()
            
            # Handle nested if/ifelse
            if token_lower in {'if', 'ifelse', 'ifelse-value'}:
                nested_result, new_i = nested_result, new_i = self._validate_if_statement(tokens, i)
                if not nested_result.is_valid:
                    result.merge(nested_result)
                i = new_i
                continue
            
            # Handle movement and other allowed commands
            if token_lower in self.allowed_commands:
                command_result, new_i = self._validate_command(tokens[i:], 0)
                if not command_result.is_valid:
                    for error in command_result.errors:
                        # Adjust line number to be relative to the original token list
                        if error.line_number is None:
                            error.line_number = line_num
                    result.merge(command_result)
                i += new_i
                continue
            
            # Skip tokens we don't specifically need to validate
            i += 1
        
        return result

    def _validate_command(self, tokens: List[Tuple[str, int]], 
                         start_idx: int) -> Tuple[ValidationResult, int]:
        """
        Validate a NetLogo command and its arguments.
        
        Args:
            tokens: List of tokens with line numbers
            start_idx: Starting index of the command
            
        Returns:
            Tuple containing:
                - ValidationResult with any errors
                - New index position after the command
        """
        result = ValidationResult(True)
        i = start_idx
        
        if i >= len(tokens):
            return result, i
        
        command, line_num = tokens[i]
        command_lower = command.lower()
        
        # Skip if not an allowed command
        if command_lower not in self.allowed_commands:
            return result, i + 1
        
        # Different validation based on command type
        if command_lower in {'fd', 'forward', 'bk', 'back', 'rt', 'right', 'lt', 'left'}:
            # Movement commands require a numeric value
            if i + 1 >= len(tokens):
                result.add_error(ValidationError(
                    f"Command '{command_lower}' needs a value",
                    line_number=line_num
                ))
                return result, i + 1
            
            next_token, next_line = tokens[i + 1]
            
            # Handle random expressions
            if next_token.lower() == 'random':
                if i + 2 >= len(tokens):
                    result.add_error(ValidationError(
                        "random needs a numeric value",
                        line_number=next_line
                    ))
                    return result, i + 2
                
                rand_value, rand_line = tokens[i + 2]
                if not self._is_valid_numeric_expression(rand_value):
                    result.add_error(ValidationError(
                        f"Invalid value after random: {rand_value}",
                        line_number=rand_line
                    ))
                
                return result, i + 3
            
            # Handle parenthesized expressions and other complex expressions
            elif next_token.lower() == '(':
                # Find the closing parenthesis
                bracket_count = 1
                expr_tokens = [next_token]
                expr_end = i + 1
                
                while expr_end < len(tokens) and bracket_count > 0:
                    expr_end += 1
                    if expr_end >= len(tokens):
                        result.add_error(ValidationError(
                            f"Unclosed parenthesis in {command_lower} argument",
                            line_number=next_line
                        ))
                        return result, i + 2
                    
                    current_token, _ = tokens[expr_end]
                    expr_tokens.append(current_token)
                    
                    if current_token == '(':
                        bracket_count += 1
                    elif current_token == ')':
                        bracket_count -= 1
                
                # Construct the full expression to validate
                full_expr = ' '.join(t for t, _ in tokens[i+1:expr_end+1])
                
                # Special case handling for common patterns
                # Simple pattern: (random N) or (random-float N)
                simple_random_pattern = r'^\(\s*random(-float)?\s+\d+(\.\d+)?\s*\)$'
                if re.match(simple_random_pattern, full_expr):
                    return result, expr_end + 1
                    
                # Check if it's a valid complex expression
                if not self._is_valid_complex_expression(full_expr):
                    # If the expression is just a simple random or random-float, accept it anyway
                    # This makes the verifier more lenient for common patterns
                    if ('random' in full_expr or 'sin' in full_expr or 'cos' in full_expr) and len(full_expr) < 30:
                        # At least it seems to be random/trig related and not too complex, so allow it
                        return result, expr_end + 1
                    else:
                        result.add_error(ValidationError(
                            f"Invalid complex expression for {command_lower}: {full_expr}",
                            line_number=next_line
                        ))
                
                return result, expr_end + 1
            
            # Handle other expressions
            elif not self._is_valid_numeric_expression(next_token) and not self._is_valid_reporter_expression(next_token):
                result.add_error(ValidationError(
                    f"Invalid value for {command_lower}: {next_token}",
                    line_number=next_line
                ))
            
            return result, i + 2
        
        elif command_lower in {'set', 'let'}:
            # Variable commands require a name and a value
            if i + 2 >= len(tokens):
                result.add_error(ValidationError(
                    f"Command '{command_lower}' needs a variable name and a value",
                    line_number=line_num
                ))
                return result, i + 1
            
            var_name, var_line = tokens[i + 1]
            value, value_line = tokens[i + 2]
            
            # Check variable name
            if not re.match(r'^[a-zA-Z][\w\-]*$', var_name):
                result.add_error(ValidationError(
                    f"Invalid variable name: {var_name}",
                    line_number=var_line
                ))
            
            # Check value
            # if not self._is_valid_numeric_expression(value) and not self._is_valid_reporter_expression(value):
            #     result.add_error(ValidationError(
            #         f"Invalid value for variable {var_name}: {value}",
            #         line_number=value_line
            #     ))
            
            return result, i + 3
        
        # For other commands, just skip them
        return result, i + 1

    def _is_valid_numeric_expression(self, expr: str) -> bool:
        """
        Validate numeric expressions.
        
        Args:
            expr: The expression to validate
            
        Returns:
            True if expression is valid, False otherwise
        """
        expr = expr.strip().lower()
        
        # Direct number match
        if self.number_pattern.fullmatch(expr):
            return True
        
        # Check for allowed variables
        if expr in self.allowed_variables:
            return True
        
        # Allow parenthesized expressions
        if expr.startswith('(') and expr.endswith(')'):
            return self._is_valid_numeric_expression(expr[1:-1])
        
        # Check for simple arithmetic expressions
        for op in self.arithmetic_operators:
            if op in expr:
                parts = expr.split(op, 1)
                if all(self._is_valid_numeric_expression(part.strip()) for part in parts):
                    return True
        
        return False

    def _is_valid_reporter_expression(self, expr: str) -> bool:
        """
        Validate reporter expressions.
        
        Args:
            expr: The expression to validate
            
        Returns:
            True if expression is valid, False otherwise
        """
        expr = expr.strip().lower()
        
        # Match reporters with arguments
        if self.reporter_pattern.match(expr):
            return True
        
        # Check for item reporter with args
        if expr.startswith('item '):
            parts = expr.split(maxsplit=2)
            if len(parts) >= 3:
                return (self._is_valid_numeric_expression(parts[1]) and 
                        parts[2] in self.allowed_variables)
        
        # Allow any known reporter name as-is
        if expr in self.allowed_reporters:
            return True
        
        return False
        
    def _is_valid_complex_expression(self, expr: str) -> bool:
        """
        Validate complex expressions including parenthesized expressions and combinations.
        
        Args:
            expr: The expression to validate
            
        Returns:
            True if expression is valid, False otherwise
        """
        expr = expr.strip().lower()
        
        # Handle parenthesized expressions
        if expr.startswith('(') and expr.endswith(')'):
            # Extract the inner content of the parentheses
            inner_expr = expr[1:-1].strip()
            
            # Check for simple numeric expressions
            if self._is_valid_numeric_expression(inner_expr):
                return True
            
            # Specialized pattern matching for common NetLogo expressions
            
            # Pattern: number + random-float number
            pattern1 = r'^\s*(\d+(\.\d+)?)\s*\+\s*random-float\s+(\d+(\.\d+)?)\s*$'
            if re.match(pattern1, inner_expr):
                return True
                
            # Pattern: number + random number
            pattern2 = r'^\s*(\d+(\.\d+)?)\s*\+\s*random\s+(\d+(\.\d+)?)\s*$'
            if re.match(pattern2, inner_expr):
                return True
            
            # Pattern: sin (random number) * number
            pattern3 = r'^\s*sin\s*\(\s*random\s+\d+(\.\d+)?\s*\)\s*\*\s*\d+(\.\d+)?\s*$'
            if re.match(pattern3, inner_expr):
                return True
            
            # Pattern: cos (random number) * number
            pattern4 = r'^\s*cos\s*\(\s*random\s+\d+(\.\d+)?\s*\)\s*\*\s*\d+(\.\d+)?\s*$'
            if re.match(pattern4, inner_expr):
                return True
            
            # Pattern: sin random number * number
            pattern5 = r'^\s*sin\s+random\s+\d+(\.\d+)?\s*\*\s*\d+(\.\d+)?\s*$'
            if re.match(pattern5, inner_expr):
                return True
                
            # Pattern: simple random expression
            pattern6a = r'^\s*random\s+\d+(\.\d+)?\s*$'
            if re.match(pattern6a, inner_expr):
                return True
                
            # Pattern: simple random-float expression
            pattern6b = r'^\s*random-float\s+\d+(\.\d+)?\s*$'
            if re.match(pattern6b, inner_expr):
                return True
            
            # Pattern: number + (nested random/math expression)
            pattern6 = r'^\s*\d+(\.\d+)?\s*\+\s*\(\s*.+\s*\)\s*$'
            if re.match(pattern6, inner_expr):
                nested_start = inner_expr.find('(')
                nested_end = inner_expr.rfind(')')
                if nested_start != -1 and nested_end != -1:
                    nested_expr = inner_expr[nested_start:nested_end+1]
                    if self._is_valid_complex_expression(nested_expr):
                        return True
                
            # Check for arithmetic with random or random-float (general case)
            for reporter in ['random', 'random-float', 'sin', 'cos']:
                if reporter in inner_expr:
                    parts = inner_expr.split(reporter, 1)
                    prefix = parts[0].strip()
                    suffix = parts[1].strip() if len(parts) > 1 else ""
                    
                    # Check for valid prefix (number + operation)
                    prefix_valid = not prefix or any(prefix.endswith(op) for op in self.arithmetic_operators)
                    
                    # Check for valid suffix (number or space + number)
                    if suffix.startswith(" "):
                        suffix_parts = suffix.split(None, 1)
                        if len(suffix_parts) > 0:
                            number_part = suffix_parts[0]
                            rest_part = suffix_parts[1] if len(suffix_parts) > 1 else ""
                            
                            # Validate number part
                            number_valid = self._is_valid_numeric_expression(number_part)
                            
                            # Validate rest (should be empty or start with an operator)
                            rest_valid = not rest_part or any(rest_part.startswith(op) for op in self.arithmetic_operators)
                            
                            if number_valid and (not rest_part or rest_valid):
                                return True
            
            # Check for expressions with arithmetic operations
            for op in self.arithmetic_operators:
                if op in inner_expr:
                    parts = inner_expr.split(op, 1)
                    left = parts[0].strip()
                    right = parts[1].strip() if len(parts) > 1 else ""
                    
                    # Validate left and right sides of operation
                    left_valid = (self._is_valid_numeric_expression(left) or 
                                 self._is_valid_reporter_expression(left) or
                                 self._is_valid_complex_expression('(' + left + ')'))
                    
                    right_valid = (self._is_valid_numeric_expression(right) or 
                                  self._is_valid_reporter_expression(right) or
                                  self._is_valid_complex_expression('(' + right + ')'))
                    
                    if left_valid and right_valid:
                        return True
        
        # Check for direct reporter expression with trigonometric functions
        for reporter in ['sin', 'cos', 'tan']:
            if expr.startswith(reporter + ' '):
                arg = expr[len(reporter):].strip()
                # Handle both direct args and parenthesized args
                if self._is_valid_numeric_expression(arg) or self._is_valid_reporter_expression(arg):
                    return True
                # Handle parenthesized args after trig function
                if arg.startswith('(') and arg.endswith(')'):
                    inner_arg = arg[1:-1].strip()
                    if self._is_valid_numeric_expression(inner_arg) or self._is_valid_reporter_expression(inner_arg):
                        return True
        
        # Check for direct reporter expression with other reporters
        for reporter in self.allowed_reporters:
            if expr.startswith(reporter + ' '):
                arg = expr[len(reporter):].strip()
                if self._is_valid_numeric_expression(arg):
                    return True
        
        return False

    def _check_value_ranges(self, code: str, 
                           code_lines: List[Tuple[int, str]]) -> ValidationResult:
        """
        Validate numeric value ranges in NetLogo code.
        
        Args:
            code: The code to validate
            code_lines: List of tuples (line_number, code)
            
        Returns:
            ValidationResult with any range violations
        """
        result = ValidationResult(True)
        
        # Extract numeric values with line numbers
        number_matches = []
        for line_num, line in code_lines:
            for match in self.number_pattern.finditer(line):
                number_matches.append((match.group(), line_num))
        
        for num_str, line_num in number_matches:
            try:
                value = float(num_str)
                # Check against configured limits
                if value > self.max_value:
                    result.add_error(ValidationError(
                        f"Value too large: {value} (maximum allowed: {self.max_value})",
                        line_number=line_num,
                        code_snippet=num_str
                    ))
                if value < self.min_value:
                    result.add_error(ValidationError(
                        f"Value too small: {value} (minimum allowed: {self.min_value})",
                        line_number=line_num,
                        code_snippet=num_str
                    ))
            except ValueError:
                # This shouldn't happen with our regex, but just in case
                result.add_error(ValidationError(
                    f"Invalid numeric value: {num_str}",
                    line_number=line_num,
                    code_snippet=num_str
                ))
        
        return result

    def measure_complexity(self, code: str) -> CodeComplexity:
        """
        Measure the complexity of NetLogo code.
        
        Args:
            code: The NetLogo code to analyze
            
        Returns:
            CodeComplexity: Enum value representing complexity level
        """
        # Clean the code
        code = re.sub(self.comment_pattern, '', code)
        code = code.lower()
        
        # Count various complexity indicators
        complexity_score = 0
        
        # 1. Basic movement commands (+1)
        if re.search(r'\b(fd|forward|bk|back|rt|right|lt|left)\b', code):
            complexity_score += 1
        
        # 2. Conditional statements (+1 per type)
        if re.search(r'\bif\b', code):
            complexity_score += 1
        if re.search(r'\bifelse\b', code):
            complexity_score += 1
        
        # 3. Variable usage (+1)
        if re.search(r'\b(set|let)\b', code):
            complexity_score += 1
        
        # 4. Advanced movement (+1)
        if re.search(r'\b(towards|distance|in-radius)\b', code):
            complexity_score += 1
        
        # 5. Random usage (+1)
        if re.search(r'\b(random|random-float)\b', code):
            complexity_score += 1
        
        # 6. Math functions (+1)
        if re.search(r'\b(sin|cos|tan)\b', code):
            complexity_score += 1
        
        # 7. Nested conditionals (+1)
        if re.search(r'\bif.*\[.*if\b', code) or re.search(r'\bifelse.*\[.*if\b', code):
            complexity_score += 1
        
        # Map score to complexity level, capping at the highest level
        if complexity_score <= 1:
            return CodeComplexity.SIMPLE
        elif complexity_score == 2:
            return CodeComplexity.BASIC
        elif complexity_score == 3:
            return CodeComplexity.MODERATE
        elif complexity_score == 4:
            return CodeComplexity.ADVANCED
        elif complexity_score == 5:
            return CodeComplexity.COMPLEX
        elif complexity_score == 6:
            return CodeComplexity.SOPHISTICATED
        else:
            return CodeComplexity.EXPERT

# Usage Example
def test_verifier():
    """Test the verifier with various inputs."""
    verifier = NetLogoVerifier()
    
    test_cases = [
        # Safe cases
        ("fd 0.5", True),
        ("fd random 10", True),
        ("rt random-float 90 fd 5", True),
        
        # Control structure cases
        ("ifelse item 0 input != 0 [rt 15 fd 0.5] [fd 1]", True),
        ("if item 1 input = 0 [lt 45 fd 1]", True),
        
        # Unsafe cases
        ("ask neighbors [fd 1]", False),
        ("fd 1 die", False),
        ("rt 90 python:run", False),
        ("fd (1", False),
        ("fd -9999", False),
        ("", False),
        
        # Edge cases
        ("fd 1 + 2", True),
        ("rt random 360 * 0.5", True),
        ("FD 1 RT 90", True),  # Case insensitive
        
        # Additional decimal test cases
        ("fd 0.25", True),
        ("rt 45.5", True),
        ("lt -0.75", True),
        
         # Complex control structure case
        ("""ifelse item 0 input != 0 [rt 15 fd 0.5] [ifelse item 2 input != 0 [fd 1] [ifelse item 1 input != 0 [lt 15 fd 0.5] [rt random 30 lt random 30 fd 5]]]""", True),
        ("""(ifelse item 2 input != 0 [  fd 1]item 0 input != 0 and item 0 input < item 1 input [  lt 15 fd 0.5]item 1 input != 0 [  rt 15 fd 0.5][  fd 1])""", True),
        
        ("lt random 20 rt random 20 fd (1 + random-float 0.5)", True),
        
        # Multi-conditional format test cases
        ("(ifelse item 0 input > 0 [fd 1] item 1 input > 0 [rt 90 fd 1] [lt 90 fd 1])", True),
        ("(ifelse-value item 0 input > 0 [1] item 1 input > 0 [2] [0])", True),
        ("(ifelse item 0 input > 0 [fd 1] item 1 input > 0 [rt 90 fd 1])", False),  # Missing final else branch
        ("(ifelse item 0 input > 0 fd 1] item 1 input > 0 [rt 90 fd 1])", False),  # Syntax error
        ("(ifelse-value item 0 input > 0 [1 + 2] item 1 input > 0 [sin random 360] [0])", True),
        ("(ifelse item 0 input > 10 and item 1 input < 5 [fd 1] item 2 input != 0 [rt 45 fd 2] [lt 45 fd 1])", True), # Complex condition with logical operator
        
        ("(ifelse   item 2 input != 0 [    fd 1  ]  item 0 input != 0 and item 0 input < item 1 input [    lt 15 fd 0.5  ]  item 1 input != 0 [    rt 15 fd 0.5  ]  [    fd 1  ])", True)
    ]
    
    for code, expected_safe in test_cases:
        is_safe, message = verifier.is_safe(code)
        print(f"\nTesting: {code}")
        print(f"Expected safe: {expected_safe}, Got: {is_safe}")
        if not is_safe:
            print(f"Message: {message}")
        assert is_safe == expected_safe, f"Test failed for: {code}"
        
        # Also test complexity measurement
        complexity = verifier.measure_complexity(code)
        print(f"Complexity: {complexity.name} ({complexity.value})")

if __name__ == "__main__":
    test_verifier()
